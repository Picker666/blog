(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{506:function(t,e,r){"use strict";r.r(e);var o=r(54),_=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"跨站点伪造请求-csrf"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#跨站点伪造请求-csrf"}},[t._v("#")]),t._v(" 跨站点伪造请求 (CSRF)")]),t._v(" "),r("p",[t._v("cross site request forgery")]),t._v(" "),r("p",[t._v("顾名思义就是通过伪造连接请求，在用户不知情的情况下，让用户以自己的身份来完成非本意操作的攻击方法。CSRF利用的是"),r("strong",[t._v("网站对浏览器的信任")]),t._v("。")]),t._v(" "),r("h2",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),r("ul",[r("li",[t._v("用户C浏览并登录信任网站A,产生cookie")]),t._v(" "),r("li",[t._v("用户C未退出网站A，在同一个浏览器危险访问网站B")]),t._v(" "),r("li",[t._v("网站B的页面存有一些攻击性的代码，会发出访问A的请求，(默认带上 网站A 的登录态 Cookie)")]),t._v(" "),r("li",[t._v("浏览器收到请求后，在用户不知情的情况下携带cookie访问网站A")]),t._v(" "),r("li",[t._v("A不知道请求是谁发的，浏览器会带上用户的cookie，所以A会根据用户的权限处理B发出的请求。这样就达到了攻击的目的。")])]),t._v(" "),r("h2",{attrs:{id:"防御"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#防御"}},[t._v("#")]),t._v(" 防御")]),t._v(" "),r("ul",[r("li",[t._v("验证码：对敏感操作加入验证码，强制用户与网站进行交互；")]),t._v(" "),r("li",[t._v("对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。")]),t._v(" "),r("li",[t._v("使用POST请求，避免使用GET，降低攻击风险，post请求攻击方需要构造一个form表单才可以发起请求，比get请求（img的src，a标签的href等等）的攻击方式复杂了一些，相对来说能降低风险，但不能阻止。")]),t._v(" "),r("li",[t._v("检查HTTP中的referer字段，该字段记录了HTTP请求的来源地址")]),t._v(" "),r("li",[r("strong",[t._v("在请求头中加入token验证字段")]),t._v("，浏览器并不会自动携带Token去请求，且Token可以携带一段加密的jwt用作身份认证，这样进行CSRF的时候仅传递了cookie，并不能表明用户身份，网站即拒绝攻击请求。")]),t._v(" "),r("li",[t._v("在http中自定义属性并验证。")])]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/6844904021308735502#heading-74",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端安全之 CSRF 攻击原理和防护方法"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=_.exports}}]);