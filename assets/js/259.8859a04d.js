(window.webpackJsonp=window.webpackJsonp||[]).push([[259],{647:function(t,e,a){"use strict";a.r(e);var _=a(54),v=Object(_.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-vs-vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-vs-vue"}},[t._v("#")]),t._v(" React VS Vue")]),t._v(" "),a("h2",{attrs:{id:"相似之处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相似之处"}},[t._v("#")]),t._v(" 相似之处")]),t._v(" "),a("h3",{attrs:{id:"_1、使用-virtual-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、使用-virtual-dom"}},[t._v("#")]),t._v(" 1、使用 Virtual DOM")]),t._v(" "),a("p",[t._v("都采用虚拟 DOM，使用相似却不相同的 diff 算法，特别是在 有 key DOM 的 diff 上，使用的算法完全不同；")]),t._v(" "),a("h3",{attrs:{id:"_2、提供响应式和组件化的视图组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、提供响应式和组件化的视图组件"}},[t._v("#")]),t._v(" 2、提供响应式和组件化的视图组件")]),t._v(" "),a("p",[t._v("都是组件化的编程，但是编程方式却不相同")]),t._v(" "),a("p",[t._v("都是响应式的编程，但是响应的方式却是不一样的")]),t._v(" "),a("h3",{attrs:{id:"_3、将注意力集中保持在核心库-而将其他功能如路由和全局状态管理交给相关的库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、将注意力集中保持在核心库-而将其他功能如路由和全局状态管理交给相关的库"}},[t._v("#")]),t._v(" 3、将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库")]),t._v(" "),a("p",[t._v("都更加关注核心库，但是Vue的状态管理和路由功能却是深度集成的。")]),t._v(" "),a("h2",{attrs:{id:"不同之处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同之处"}},[t._v("#")]),t._v(" 不同之处")]),t._v(" "),a("h3",{attrs:{id:"_1、diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、diff-算法"}},[t._v("#")]),t._v(" 1、diff 算法")]),t._v(" "),a("ul",[a("li",[t._v("React")])]),t._v(" "),a("p",[t._v("直接查找，位置不同 - 后移")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/library/react/diff.html"}},[t._v("React Diff")])],1),t._v(" "),a("ul",[a("li",[t._v("Vue")])]),t._v(" "),a("p",[t._v("双指针遍历+搜索+其他")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/library/vue/diff.html"}},[t._v("Vue Diff")])],1),t._v(" "),a("h3",{attrs:{id:"_2、运行时的性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、运行时的性能"}},[t._v("#")]),t._v(" 2、运行时的性能")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("React 性能")]),t._v(" "),a("ul",[a("li",[t._v("（1）、16之前 React 的更新是遍历整颗DOM树，并且是递归更新，该过程不可相应用户的操作；")]),t._v(" "),a("li",[t._v("（2）、16之后 Fiber 的加入，React的更新过程变得可中断、可恢复，更新过程可以优先响应用户的交互，但本质还是一个全量的更新")]),t._v(" "),a("li",[t._v("（3）、React 优化 类组件，PureComponent， shouldComponentUpdate，hooks组件 useMemo, useCallback, memo 等等。")])])]),t._v(" "),a("li",[a("p",[t._v("Vue 性能")])])]),t._v(" "),a("p",[t._v("Vue 的更新逻辑依赖发布订阅和Proxy/Object.defineProperty，是一种精确的订阅和依赖更新系统，个人认为性能更好。并且开发者不需要考虑性能优化。")]),t._v(" "),a("h3",{attrs:{id:"_3、使用性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、使用性"}},[t._v("#")]),t._v(" 3、使用性")]),t._v(" "),a("p",[t._v("React 使用jsx语法，all in js；")]),t._v(" "),a("p",[t._v("Vue 更推荐使用模版语法，这对初学者更加友好；")]),t._v(" "),a("p",[t._v("另外，Vue还进行了一些额外的开发以方便我们的使用，比如指令： v-on，v-bind，v-model等等功能强大，比如插槽；")]),t._v(" "),a("p",[t._v("样式的处理方式也更加方便")]),t._v(" "),a("h3",{attrs:{id:"_4、周边"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、周边"}},[t._v("#")]),t._v(" 4、周边")]),t._v(" "),a("ul",[a("li",[t._v("路由")])]),t._v(" "),a("p",[t._v("相比Vue，React的路由相对比较简单，单纯的路由；")]),t._v(" "),a("p",[t._v("Vue 的路由和 Vue 本身深度集成，有不同的钩子，全局的路由守卫（beforeEach、beforeResolve、afterEach），路由独享的守卫（beforeEnter），组件内守卫（beforeRouteEnter，beforeRouteUpdate， beforeRouteLeave）")]),t._v(" "),a("ul",[a("li",[t._v("状态管理")])]),t._v(" "),a("p",[t._v("一般来说React的状态管理我们会用到Redux+Redux-thunk，功能强大，但是使用来了繁琐；")]),t._v(" "),a("p",[t._v("对 Vue 来说，使用深度集成的 Vuex，同样功能强大，使用方便，提供很多易用的API，并且支持异步的操作。")])])}),[],!1,null,null,null);e.default=v.exports}}]);