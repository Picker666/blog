(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{426:function(t,a,s){"use strict";s.r(a);var e=s(54),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),s("h2",{attrs:{id:"判断对象是否存活的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#判断对象是否存活的方法"}},[t._v("#")]),t._v(" 判断对象是否存活的方法")]),t._v(" "),s("h3",{attrs:{id:"_1、引用计数法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、引用计数法"}},[t._v("#")]),t._v(" 1、引用计数法")]),t._v(" "),s("p",[t._v("每个对象上都有一个引用计数，对象每被引用一次，引用计数器就+1，对象引用被释放，引用计数器-1，直到对象的引用计数为0，对象就标识可以回收。但是这个算法有明显的缺陷，对于循环引用的情况下，"),s("strong",[t._v("循环引用的对象就不会被回收")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceCountingGC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" Object instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" finalint _1MB "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  privatebyte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" bigSize "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newbyte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" _1MB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("testGC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    ReferenceCountingGC objA "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceCountingGC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    ReferenceCountingGC objB "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceCountingGC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    objA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    objB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    objA "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    objB "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    System"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//发生嵌套引用，但是在java中，objA和objB的内存可以被回收")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("h3",{attrs:{id:"_2、可达性分析算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、可达性分析算法"}},[t._v("#")]),t._v(" 2、可达性分析算法")]),t._v(" "),s("p",[t._v("基本思路是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下探索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，")]),t._v(" "),s("p",[t._v("换句话说：引用链到达根对象（GC Roots），如果到达不了，则判断该对象不可用。")]),t._v(" "),s("p",[t._v("则证明此对象是不可用的。在Java语言中，可作为GC Roots的对象包括下面几种：")]),t._v(" "),s("ul",[s("li",[t._v("（1）、虚拟机栈（栈帧中的本地变量表）中引用的对象；")]),t._v(" "),s("li",[t._v("（2）、方法区中类静态属性引用的对象；")]),t._v(" "),s("li",[t._v("（3）、方法区中常量引用的对象；")]),t._v(" "),s("li",[t._v("（4）、本地方法栈中JNI（即一般说的Native方法）引用的对象。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/blog/images/base/gc1.jpeg",alt:"GC Roots的对象"}})]),t._v(" "),s("h2",{attrs:{id:"引用类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[t._v("#")]),t._v(" 引用类型")]),t._v(" "),s("ul",[s("li",[t._v("（1）强引用")])]),t._v(" "),s("p",[t._v("强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()’'这类的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。")]),t._v(" "),s("ul",[s("li",[t._v("（2）软引用")])]),t._v(" "),s("p",[t._v("需要用 "),s("code",[t._v("java.lang.ref.SoftReference")]),t._v(" 类来实现，可以让对象豁免一些垃圾收集。")]),t._v(" "),s("p",[t._v("软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次还没有足够的内存，才会抛出内存溢出异常。")]),t._v(" "),s("ul",[s("li",[t._v("（3）弱引用")])]),t._v(" "),s("p",[t._v("弱引用需要用 "),s("code",[t._v("java.lang.ref.WeakReference")]),t._v(" 类来实现，它比软引用的生存期更短。")]),t._v(" "),s("p",[t._v("弱引用也是用来描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。")]),t._v(" "),s("ul",[s("li",[t._v("（4）虚引用")])]),t._v(" "),s("p",[t._v("虚引用需要 "),s("code",[t._v("java.lang.ref.PhantomReference")]),t._v(" 来实现。")]),t._v(" "),s("p",[t._v("虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是"),s("strong",[t._v("能在这个对象被收集器回收时收到一个系统通知")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"对象是否一定要清除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象是否一定要清除"}},[t._v("#")]),t._v(" 对象是否一定要清除")]),t._v(" "),s("p",[t._v("假设在可达性分析算法中某个对象不可达，它也并非”非死不可”。如果这个对象覆盖了finalize（）方法且这个方法没有被JVM调用过，则JVM会执行finalize（）方法。这时你可以在这个方法中重新使某个引用指向该对象。当然，finalize()方法只能救它一次。")]),t._v(" "),s("h2",{attrs:{id:"垃圾回收算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),s("h3",{attrs:{id:"_1、标记-清除-mark-sweep-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、标记-清除-mark-sweep-算法"}},[t._v("#")]),t._v(" 1、标记-清除（Mark-Sweep）算法")]),t._v(" "),s("p",[t._v("最基础的垃圾回收算法，分为两个阶段，"),s("code",[t._v("标记")]),t._v("和"),s("code",[t._v("清除")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("标记阶段标记出所有需要回收的对象;")]),t._v(" "),s("li",[t._v("清除阶段回收被标记的对象所占用的空间。")])]),t._v(" "),s("p",[t._v("从图中我们就可以发现，该算法最大的问题是"),s("code",[t._v("内存碎片化严重")]),t._v("，后续可能发生"),s("code",[t._v("大对象不能找到可利用空间")]),t._v("的问题。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/blog/images/base/gc2.jpeg",alt:"GC Roots的对象"}})]),t._v(" "),s("h3",{attrs:{id:"_2、标记整理-mark-compact-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、标记整理-mark-compact-算法"}},[t._v("#")]),t._v(" 2、标记整理(Mark-Compact)算法")]),t._v(" "),s("p",[t._v("标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是"),s("code",[t._v("将存活对象移向内存的一端")]),t._v("，然后清除端边界外的对象。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/blog/images/base/gc3.jpeg",alt:"GC Roots的对象"}})]),t._v(" "),s("p",[t._v("解决了 标记-清除算法 内存碎片化严重的问题。")]),t._v(" "),s("p",[t._v("但是，整理过程"),s("code",[t._v("效率低下")]),t._v("；")]),t._v(" "),s("h3",{attrs:{id:"_3、复制-coping-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、复制-coping-算法"}},[t._v("#")]),t._v(" 3、复制（Coping）算法")]),t._v(" "),s("p",[t._v("为了解决标记清除（Mark-Sweep）算法"),s("code",[t._v("内存碎片化的缺陷")]),t._v("而被提出的算法。")]),t._v(" "),s("p",[t._v("按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块"),s("code",[t._v("内存满后")]),t._v("将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图。")]),t._v(" "),s("p",[t._v("这种算法优点：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("实现简单")])]),t._v(" "),s("li",[s("code",[t._v("内存效率高")])]),t._v(" "),s("li",[s("code",[t._v("不易产生碎片")])])]),t._v(" "),s("p",[t._v("不足：")]),t._v(" "),s("ul",[s("li",[t._v("可用内存被"),s("code",[t._v("压缩")]),t._v("到了原本的一半。")]),t._v(" "),s("li",[t._v("且存活对象增多的话，Copying算法的"),s("code",[t._v("效率会大大降低")]),t._v("。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/blog/images/base/gc4.jpeg",alt:"GC Roots的对象"}})]),t._v(" "),s("h3",{attrs:{id:"_4、分代收集-generational-collection-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、分代收集-generational-collection-算法"}},[t._v("#")]),t._v(" 4、分代收集（Generational Collection）算法")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/base/browser/garbageCollectionByV8.html#_3、v8的垃圾回收策略"}},[t._v("分代收集法")]),t._v("是目前"),s("code",[t._v("大部分JVM")]),t._v("所采用的方法")],1),t._v(" "),s("p",[t._v("其核心思想是:")]),t._v(" "),s("p",[t._v("根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为"),s("code",[t._v("老生代")]),t._v("(Tenured/Old Generation)和"),s("code",[t._v("新生代")]),t._v("(YoungGeneration)。")]),t._v(" "),s("p",[s("strong",[t._v("老生代")]),t._v("的特点是每次垃圾回收时只有"),s("code",[t._v("少量")]),t._v("对象需要被回收")]),t._v(" "),s("p",[s("strong",[t._v("新生代")]),t._v("的特点是每次垃圾回收时都有"),s("code",[t._v("大量")]),t._v("垃圾需要被回收，因此可以根据"),s("code",[t._v("不同区域选择不同的算法")]),t._v("。")]),t._v(" "),s("p",[t._v("目前"),s("code",[t._v("大部分JVM")]),t._v("的GC对于新生代都采取"),s("code",[t._v("Copying算法")]),t._v("，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的"),s("code",[t._v("Eden")]),t._v("空间和两个"),s("code",[t._v("较小")]),t._v("的"),s("code",[t._v("Survivor")]),t._v("空间(From Space, To Space)，每次使用"),s("code",[t._v("Eden")]),t._v("空间和其中的一块"),s("code",[t._v("Survivor")]),t._v("空间，当进行回收时，将该两块空间中还存活的对象复制到"),s("code",[t._v("另一块Survivor")]),t._v("空间中。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/blog/images/base/gc5.jpeg",alt:"GC Roots的对象"}})]),t._v(" "),s("p",[t._v("而老生代因为每次只回收少量对象，因而采用"),s("code",[t._v("Mark-Compact")]),t._v("算法。")]),t._v(" "),s("ul",[s("li",[t._v("Young区分为Eden区和两个Survivor区域，其中所有"),s("code",[t._v("新创建")]),t._v("的对象都在Eden区，当Eden区满后会触发"),s("code",[t._v("minor GC")]),t._v("将仍然存活的对象复制到其中一个Survivor区域中，另外一个Survivor区域中的存活对象也复制到这个Survivor区域中，保证始终有一个Survivor区域时空的。")]),t._v(" "),s("li",[t._v("当Eden区域满后会将对象存放到Survivor区域中，如果Survivor区域仍然存放不下这些对象，GC收集器会将这些对象直接存放到Old区域。如果在Survivor区域中的对象足够老，也直接存放到Old区域中。如果Old区域也满了，将会触发"),s("code",[t._v("Full GC")]),t._v("，回收整个堆内存。")]),t._v(" "),s("li",[t._v("Perm区域存放的主要是类的Class对象，如果一个类被频繁地加载，也可能会导致Perm区满，Perm区的垃圾回收也是由Full GC触发的。")])]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/base/browser/garbageCollectionByV8.html"}},[t._v("V8引擎的垃圾回收")])],1)])}),[],!1,null,null,null);a.default=n.exports}}]);