(window.webpackJsonp=window.webpackJsonp||[]).push([[262],{650:function(t,a,e){"use strict";e.r(a);var v=e(54),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue2-computed-和-watch-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-computed-和-watch-的区别"}},[t._v("#")]),t._v(" Vue2 computed 和 watch 的区别")]),t._v(" "),e("h2",{attrs:{id:"computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),e("p",[t._v("计算属性")]),t._v(" "),e("ul",[e("li",[t._v("当计算属性依赖的值发生变化时，触发计算，并返回最新的值。")]),t._v(" "),e("li",[t._v("计算属性结果会被缓存，除非依赖的属性值发生变化才会重新计算。")]),t._v(" "),e("li",[t._v("不支持异步，当computed内有异步操作时无效，无法监听数据的变化")]),t._v(" "),e("li",[t._v("computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值")])]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/sourceAnalysis/vue2Computed.html"}},[t._v("computed 源码解析")])],1),t._v(" "),e("h2",{attrs:{id:"watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),e("p",[t._v("侦听属性")]),t._v(" "),e("ul",[e("li",[t._v("监听某一个值，当被监听的值发生变化时，执行对应的操作")]),t._v(" "),e("li",[t._v("watch里面有一个属性为deep，含义是：是否深度监听某个对象的值, 该值默认为false。")]),t._v(" "),e("li",[t._v("watch里面有一个属性为immediate，是否在初始化的时候监听生效，默认是false；")]),t._v(" "),e("li",[t._v("watch支持异步；")]),t._v(" "),e("li",[t._v("监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；")]),t._v(" "),e("li",[t._v("监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，")])])])}),[],!1,null,null,null);a.default=s.exports}}]);