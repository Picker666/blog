(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{623:function(e,t,o){"use strict";o.r(t);var v=o(54),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"react生命周期-新"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期-新"}},[e._v("#")]),e._v(" React生命周期（新）")]),e._v(" "),o("p",[e._v("react 生命周期(新)的更新图:")]),e._v(" "),o("p",[o("img",{attrs:{src:"/blog/images/react/2.png",alt:"react 生命周期(新)的更新图"}})]),e._v(" "),o("p",[e._v("react16.4后使用了新的生命周期，使用 "),o("code",[e._v("getDerivedStateFromProps")]),e._v("代替了旧的 "),o("code",[e._v("componentWillReceiveProps")]),e._v(" 及 "),o("code",[e._v("componentWillMount")]),e._v(" 。使用 "),o("code",[e._v("getSnapshotBeforeUpdate")]),e._v(" 代替了旧的 "),o("code",[e._v("componentWillUpdate")]),e._v(" 。")]),e._v(" "),o("h2",{attrs:{id:"getderivedstatefromprops"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#getderivedstatefromprops"}},[e._v("#")]),e._v(" "),o("code",[e._v("getDerivedStateFromProps")])]),e._v(" "),o("p",[o("code",[e._v("getDerivedStateFromProps(nextProps, prevState)")])]),e._v(" "),o("p",[e._v("旧的 "),o("code",[e._v("React")]),e._v(" 中 "),o("code",[e._v("componentWillReceiveProps")]),e._v(" 方法是用来判断前后两个 "),o("code",[e._v("props")]),e._v(" 是否相同，如果不同，则将新的 "),o("code",[e._v("props")]),e._v(" 更新到相应的 "),o("code",[e._v("state")]),e._v(" 上去。在这个过程中我们实际上是可以访问到当前 "),o("code",[e._v("props")]),e._v(" 的，这样我们可能会对 "),o("code",[e._v("this.props")]),e._v(" 做一些奇奇怪怪的操作，很可能会破坏 "),o("code",[e._v("state")]),e._v(" 数据的单一数据源，导致组件状态变得不可预测。(比如根据 "),o("code",[e._v("props")]),e._v(" 变化，操作一些副作用)")]),e._v(" "),o("p",[e._v("而在 "),o("code",[e._v("getDerivedStateFromProps")]),e._v(" 中禁止了组件去访问 "),o("code",[e._v("this")]),e._v("，强制让开发者去比较 "),o("code",[e._v("nextProps")]),e._v(" 与 "),o("code",[e._v("prevState")]),e._v(" 中的值，以确保当开发者用到  "),o("code",[e._v("getDerivedStateFromProps")]),e._v(" 这个生命周期函数时，就是在根据当前的 "),o("code",[e._v("props")]),e._v(" 来更新组件的 "),o("code",[e._v("state")]),e._v(" ，而不是去访问 "),o("code",[e._v("this.props")]),e._v(" 并做其他一些让组件自身状态变得更加不可预测的事情。")]),e._v(" "),o("h2",{attrs:{id:"getsnapshotbeforeupdate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#getsnapshotbeforeupdate"}},[e._v("#")]),e._v(" getSnapshotBeforeUpdate")]),e._v(" "),o("p",[o("code",[e._v("getSnapshotBeforeUpdate(prevProps, prevState)")])]),e._v(" "),o("p",[e._v("在 "),o("code",[e._v("React")]),e._v(" 开启异步渲染模式后，在执行函数时读到的 "),o("code",[e._v("DOM")]),e._v(" 元素状态并不总是渲染时相同，这就导致在 "),o("code",[e._v("componentDidUpdate")]),e._v(" 中使用 "),o("code",[e._v("componentWillUpdate")]),e._v(" 中读取到的 "),o("code",[e._v("DOM")]),e._v(" 元素状态是不安全的，因为这时的值很有可能已经失效了。")]),e._v(" "),o("p",[e._v("而 "),o("code",[e._v("getSnapshotBeforeUpdate")]),e._v(" 会在 "),o("code",[e._v("render")]),e._v(" 之后，真实 "),o("code",[e._v("DOM")]),e._v(" 渲染之前被调用，也就是说在 "),o("code",[e._v("getSnapshotBeforeUpdate")]),e._v(" 中读取到的 "),o("code",[e._v("DOM")]),e._v(" 元素状态是可以保证与 "),o("code",[e._v("componentDidUpdate")]),e._v(" 中一致的。")]),e._v(" "),o("p",[e._v("getSnapshotBeforeUpdate()方法在呈现DOM之前被调用。用于在render后，DOM更新后存储状态的先前值。")]),e._v(" "),o("p",[e._v("getSnapshotBeforeUpdate()方法返回的任何值都将用作componentDidUpdate()方法的参数。此函数始终与componentDidUpdate()方法一起使用。")]),e._v(" "),o("p",[e._v("它接受两个参数，它们是prevProps和prevState只是相关组件为re-rendered之前的道具或状态。")])])}),[],!1,null,null,null);t.default=_.exports}}]);