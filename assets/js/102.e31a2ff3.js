(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{490:function(t,a,_){"use strict";_.r(a);var s=_(54),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"作用域链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),_("h2",{attrs:{id:"一、作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、作用域"}},[t._v("#")]),t._v(" 一、作用域")]),t._v(" "),_("h3",{attrs:{id:"_1、定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、定义"}},[t._v("#")]),t._v(" 1、定义")]),t._v(" "),_("p",[t._v("作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。简言之作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。")]),t._v(" "),_("h3",{attrs:{id:"_2、-分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、-分类"}},[t._v("#")]),t._v(" 2、 分类")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("在ES6阶段之前，作用域分为两种")]),t._v(" "),_("ul",[_("li",[t._v("全局作用域")]),t._v(" "),_("li",[t._v("函数作用域；")])])]),t._v(" "),_("li",[_("p",[t._v("进行ES6之后，作用域分为")]),t._v(" "),_("ul",[_("li",[t._v("全局作用域")]),t._v(" "),_("li",[t._v("函数作用域")]),t._v(" "),_("li",[t._v("块级作用域")])])])]),t._v(" "),_("h4",{attrs:{id:"_1-、-全局作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-、-全局作用域"}},[t._v("#")]),t._v(" （1）、 全局作用域")]),t._v(" "),_("p",[t._v("在该作用域中的对象在代码的任何地方都能访问，其生命周期伴随着页面的生命周期。例如以下内容均在全局作用域中。")]),t._v(" "),_("ul",[_("li",[t._v("window上的属性（在浏览器中）")]),t._v(" "),_("li",[t._v("最外层的函数")]),t._v(" "),_("li",[t._v("最外层定义的变量")]),t._v(" "),_("li",[t._v("未定义直接赋值的变量")]),t._v(" "),_("li",[t._v("全局对象属性")])]),t._v(" "),_("p",[t._v("js规定的全局对象的属性，三个值（Infinity、NaN、undefined）、九个函数（parseInt、parseFloat、decodeURI、encodeURI……）、一些构造器（Date、Array等）、四个用于当做命名空间的对象（Atomics、JSON、Math、Reflect）。")]),t._v(" "),_("h4",{attrs:{id:"_2-、-函数作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-、-函数作用域"}},[t._v("#")]),t._v(" （2）、 函数作用域")]),t._v(" "),_("p",[t._v("在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。在函数执行结束之后，函数内部定义的变量会被销毁。")]),t._v(" "),_("h4",{attrs:{id:"_3-、块级作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-、块级作用域"}},[t._v("#")]),t._v(" （3）、块级作用域")]),t._v(" "),_("p",[t._v("在ES6阶段，出现了块的概念，新增了块级作用域，同时新增了let、const命令。块级作用域简言之就是使用一对大括号{}包裹的一段代码，通过单独的大括号、if块、while块、for块、try/catch/finally等都会产生块级作用域。（对于let和const在块级作用域的特征可见前端百题斩【002】）")]),t._v(" "),_("h2",{attrs:{id:"二、作用域链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、作用域链"}},[t._v("#")]),t._v(" 二、作用域链")]),t._v(" "),_("h3",{attrs:{id:"_1、定义-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、定义-2"}},[t._v("#")]),t._v(" 1、定义")]),t._v(" "),_("p",[t._v("在每个执行上下文的变量环境中，都包含一个外部引用（成为outer），用来指向外部的指向上下文。当在查找一个变量的时候，如果在当前的变量环境中没有找到，js引擎会继续在outer所指向的执行上下文中查找，把这个查找的链条称为作用域链。")]),t._v(" "),_("p",[t._v("作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。")]),t._v(" "),_("h3",{attrs:{id:"_2、组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、组成"}},[t._v("#")]),t._v(" 2、组成")]),t._v(" "),_("p",[t._v("作用域链由两部分组成，分别是[[scope]]属性和AO。")]),t._v(" "),_("p",[t._v("[[scope]]属性：指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO")]),t._v(" "),_("p",[t._v("AO：自身活动对象，也就是该执行上下文中的变量对象。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("扩展")]),t._v(" "),_("p",[t._v("如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。")])]),t._v(" "),_("h3",{attrs:{id:"_3、查找规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、查找规则"}},[t._v("#")]),t._v(" 3、查找规则")]),t._v(" "),_("p",[t._v("从当前的执行作用域开始查找变量；\n如果在当前作用域中找不到该变量，则向上一级进行查找；\n继续向上一层查找，直到最外层的全局作用域。")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/6",target:"_blank",rel:"noopener noreferrer"}},[t._v("更加详细的解读"),_("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=v.exports}}]);